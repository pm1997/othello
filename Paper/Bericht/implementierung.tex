\chapter{Implementierung der KI}
Die theoretischen Grundlagen werden nun angewandt und in ein Python \ot\ Spiel implementiert. \unsure{anders?}
\section{Vorgehensweise}
In den folgenden Unterkapiteln  werden verschiedene Spielalgorithmen vorgestellt und implementiert. Anschließend werden diese verbessert und auch unter Berücksichtigung des Laufzeitverhaltens analysiert.
\\Zunächst wird aber die grundsätzliche Programmstruktur erläutert und das Spielgerüst implementiert, damit unterschiedliche Spieler es ausführen können.
\section{Grundlegende Spiel-Elemente}
Die Python Implementierung befindet sich im Verzeichnis \mxZitat{python} des zu diesem Projekt gehörenden git Repository. Die einzelnen Komponenten wurden unter thematischen Gesichtspunkten in verschiedenen Dateien organisiert.
\\Die hier vorhanden Datein enthalten den Code der das Spiel zur Ausführung bringt sowie die Datenstrukturen, die zum Speichern eines Zuges verwendet werden. Auf diese wird in diesem Abschnitt noch detailiert eingegangen.
\\Im Unterverzeichnis \mxZitat{Players} befinden sich die Implementierungen einzelner Spielstrategien. Diese werden im nachfolgenden Abschnitt detailiert behandelt.
\subsection{Die Klasse \mxZitat{Othello}}
Die Klasse \mxZitat{Othello} modelliert einen Spielzustand und enthält die Grundlegende Spiellogik wie bspw. die Berechnung erlaubter Züge. Nachfolgend wird auf die Art der Speicherung eines Spielzustandes und auf die wichtigsten Funktionen dieser Klasse eingegangen.
\paragraph{Klassenvariablen}
In Listing \ref{lst:class-vars-othello} sind alle Klassenvariablen, sowie deren Initialisierungswerte angegeben.
\begin{enumerate}
\item \code{\_board}: Bei \code{\_board} handelt es sich um eine Liste von Listen, zur Modellierung der zweidimensionalen Struktur des Spielbretts. Initialisiert wird das Spielbrett in seinem Leerzustand. Daher wird zu Beginn jedes Feld auf \code{0} zur Repräsentation des leeren Feldes gesetzt.
\item \code{\_current\_player}: Speichert den Spieler, der im modellierten Spielzustand an der Reihe ist.
\item \code{\_last\_turn\_passed} wird verwendet um zu speichern ob der vorherige Spieler  passen musste. Dadurch kann das Spiel sobald zwei Spieler unmittelbar nacheinander passen müssen beendet werden.
\item \code{\_game\_is\_over} wird auf \code{True} gesetzt sobald das Spiel beendet ist
\item \code{\_fringe}] In \code{\_fringe} werden alle Felder des Spielfeldes gespeichert die in eine Richtung unmittelbar neben einem bereits besetzten Feld liegen. Durch die Mitführung dieser Information muss zur Berechnung der erlaubten Züge nicht jedes mal über das Spielfeld iteriert werden um zunächst die infrage kommenden Felder zu ermitteln.
\item \code{\_turning\_stones}: Enthält als Schlüssel alle erlaubten Züge und als Wert jeweils eine Liste jener Spielsteine die durch ausführen des Zuges umgedreht werden. Da zur Ermittlung der erlaubten Züge diese Information bereits berechnet werden muss wird sie in Form des Dictionarys vorgehalten um diese an anderer Stelle nicht erneut berechnen zu müssen.
\item \code{\_taken\_moves}: Speichert alle ausgeführten Züge die erforderlich waren um den modellierten Spielzustand zu erreichen, da einige Algorithmen diese Information benötigen.
\item \code{\_turn\_nr}: Speichert die Nummer des aktuellen Spielzuges, da die verwendete Strategie bei einigen Algorithmen davon abhängt, wie weit das Spiel schon fortgeschritten ist.
\end{enumerate}
\begin{lstlisting}[caption = {Klassenvariablen der Klasse \mxZitat{Othello}}, language = cpp, captionpos = t , numbers=left, label={lst:class-vars-othello}]
    _board = [[0 for _ in range(8)] for _ in range(8)]
    _current_player = None
 
    _last_turn_passed = False
    _game_is_over = False

    _fringe = set()
    _turning_stones = dict()
    
    _taken_moves = dict()
    _turn_nr = 0
\end{lstlisting}
\paragraph{Die Funktion \code{\_compute\_available\_moves}}
 ist in Listing \ref{lst:fct-compute-available-moves} angegeben und wird verwendet um die Inhalte des Dictionaries \code{\_turning\_stones} zu berechnern.
\\Da beiden Spielern in der Regel nicht die gleichen Züge zur Verfügung stehen muss zunaächst der vorherige Inhalt von \code{\_turning\_stones} gelöscht werden. Dies geschieht in Zeile 2 indem die Datenstruktur neu initialisiert wird.
\\In Zeile 3 wird eine lokale Referenz des zur Darstellung eines durch den aktuellen Spieler besetzen Feldes verwendeten Symbols erzeugt.
\\Mit der in Zeile 4 beginnenden Schleife wird über alle in Frage kommenden Züge in der Menge \code{\_fringe} iteriert um zu ermitteln, ob dieser Zug erlaubt wäre.
\\Dazu wird zunächst eine lokale Menge initialisiert um die durch spielen dieser Position gedrehten Steine zu speichern (Zeile 5).
\\Nun muss ausgehend von der derzeit betrachteten Position ermittelt werden ob in irgendeine Richtung Spielsteine gedreht werden würden. Dies erfolgt durch die in Zeile 6 beginnende Schleife.
\\Dazu wird zunächst das nächste Feld in diese Richtung unter Verwendung einer Hilfsfunktion ermittelt (Zeile 7) und anschließend eine weitere termporäre Menge der in dieser Richtung gedrehten Steine initialisiert (Zeile 8)
\\Die entsprechende Richtung muss nun solange weiter verfolgt werden wie ein weiterer Nachbar in diese Richtung vorhanden ist. Dies geschieht durch die in Zeile 9 beginnedne Schleife.
\\Da in den nachfolgenden Schritten ermittelt werden muss welcher Spieler das derzeit betrachtete Feld besetzt hat, werden die Indizes der derzeitigen  ausgepackt (Zeile 10) und dann verwendet um zu ermitteln welchen Wert das Feld detzeit hat (Zeile 11).
\\Nun gibt es drei mögliche Fälle:
\begin{enumerate}
\setcounter{enumi}{0}
\item Es befindet sich kein Stein auf dem derzeit betrachteten Feld. In diesem Fall wird die Abfrage in Zeile 12 positiv ausgewertet und diese Richtung muss nicht weiter verfolgt werden. Entsprechend wird die while-Schleife in Zeile 13 abgebrochen.
\item Das derzeit betrachtete Feld wird durch den anderen Spieler besetzt. In diesem Fall ist die Abfrage in Zeile 14 positiv. Da der Stein ggf. umgedreht werden würde, wird die aktuelle Position gespeichert (Zeile 15)
\item Das derzeit betrachtete Feld wird durch den Spieler selbst besetzt. In diesem Fall wird die Abfrage in Zeile 16 positiv ausgewertet. Nun werden alle Steine zwischen der Ausgangsposition und der derzeitigen gedreht. Daher wird die Menge der durch diesen Zug gedrehten Steine mit der in diese Richtung befindlichen Steine vereinigt (Zeile 17) und die Schleife verlassen (Zeile 18).
\end{enumerate}
In Zeile 19 wird das nächste Feld in diese Richtung berechnet.
\\Gemäß der Regeln muss durch jeden Zug mindestens ein Stein gedreht werden. Aus diesem Grund wird nun ermittelt ob dies bei diesem Zug gegeben wäre (Zeile 20). Ist dies der Fall so werden die gedrehten Steine für diesen Zug in \code{\_stones\_to\_turn} gespeichert (Zeile 21).
\\Hat ein Spieler nun keine Möglichkeiten einen Zug durchzuführen, so sind in \code{\_stones\_to\_turn} keine Züge enthalten. Dieser Fall muss besonders behandelt werden. Tritt er ein, so wird die Abfrage in Zeile 22 positiv ausgewertet.
\\In diesem Fall muss nochmal unterschieden werden, ob der vorherige Spieler ebenfalls keinen Zug zur Auswahl hatte (Zeile 23).
\\Falls ja so ist das Spiel zu ende. Dies wird durch setzen von \code{\_game\_is\_over} gespeichert (Zeile 24).
\\Falls nein (Zeile 25), so wird gespeichert, dass der Spieler passen musste (Zeile 26) und der nächste Zug vorbereitet (Zeile 27)
Hat der Spieler hingegen eine Zugmöglichkeit (Zeile 28) so hat er aus Sicht des folgenden Zuges nicht passen müssen. Entsprechend wird \code{\_last\_turn\_passed} wieder auf \code{False} gesetzt. 
\begin{lstlisting}[caption = {Die Funktion \code{\_compute\_available\_moves}}, language = cpp, captionpos = t , numbers=left, label={lst:fct-compute-available-moves}]
    def _compute_available_moves(self):
        self._turning_stones = dict()
        own_symbol = self._current_player
        for current_position in self._fringe:
            position_turns = set()
            for direction in DIRECTIONS:
                next_step = Othello._next_step(current_position, direction)
                this_direction = set()
                while next_step is not None:
                    (current_x, current_y) = next_step
                    current_value = self._board[current_x][current_y]
                    if current_value == EMPTY_CELL:
                        break
                    elif current_value != own_symbol:
                        this_direction.add(next_step)
                    elif current_value == own_symbol:
                        position_turns = position_turns | this_direction
                        break
                    next_step = Othello._next_step(next_step, direction)
            if len(position_turns) > 0:
                self._turning_stones[current_position] = position_turns
        if len(self._turning_stones) == 0:
            if self._last_turn_passed:
                self._game_is_over = True
            else:
                self._last_turn_passed = True
                self._prepare_next_turn()
        else:
            self._last_turn_passed = False
\end{lstlisting}
\paragraph{Weitere Funktionen der Klasse \mxZitat{Othello}}
Die Klasse \mxZitat{Othello} enthält weitere Funktionen auf die hier jedoch nicht im Detail eingegangen werden soll. Dennoch sei hier jeweils kurz deren Verwendungszweck der wichtigsten Funktionen genannt:
\begin{enumerate}
\item \code{play\_position} verändert den Spielzustand dahingehend, dass der übergebene Zug, sofern er erlaubt ist, ausgeführt wird, die entsprechenden Steine des Gegners gedreht und dessen Zug vorbereitet wird. Dabei wird auch die \code{\_fringe} entsprechend aktualisiert.
\item \code{set\_available\_moves} verändert \code{\_stones\_to\_turn} dahingehend, dass nur noch übergebene Positionen enthalten sind. Kann damit zum Filtern der erlaubten Züge verwendet werden.
\item \code{get\_available\_moves}: Gibt die erlaubten Züge zur Verwendung in den Spieler-\\implementierungen zurück
\item \code{other\_player}: Gibt das Symbol des anderen Spielers zurück
\item \code{utility}: Gibt gemäß der Definition eines Spiels 0, 1 oder -1 zurück.
\item \code{get\_winner}: Ermittelt den Gewinner des Spiels und gibt ihn zurück.
\item \code{get\_statistics}: Gibt die Anzahl der Felder pro Spieler zurück.
\item \code{get\_current\_player}: Gibt den derzeitigen Spieler zurück.
\item \code{game\_is\_over}: Gibt zurück ob das Spiel bereits zu Ende ist.
\item \code{init\_game}: Bereitet den Start eines Spiels vor indem die initial besetzen Felder entsprechen gesetzt werden. Der beginnende Spieler festgelegt und die  \code{\_fringe} vorbereitet, sowie \code{\_stones\_to\_turn} für den ersten Zug berechnet.
\end{enumerate}
\subsection{Die Datei \mxZitat{main-game.py}}
\section{Spieler}
Es gibt folgende \mxZitat{Haupt}-Spieler:
\begin{enumerate}
\setcounter{enumi}{-1}
\item Human Player
\item Random Player
\item Monte Carlo
\item Alpha-Beta Pruning
\item Machine Learning
\end{enumerate}
Spieler 0 wird für die manuelle Eingabe von Zügen eingesetzt. Alle anderen Spieler sind Computerspieler und spielen automatisch.
Nachfolgend werden die einzelnen Computerspieler kurz beschrieben.

\subsection{Random}
Der Spieler Random wählt aus der Liste der möglichen Züge zufällig einen Zug aus und gibt diesen an die Hauptfunktion zurück.

\subsection{Monte Carlo}
Dieser Spieler verwendet den in Kapitel \ref{mc_algo} verwendeten Algorithmus um den Zug mit der höchsten Gewinnwahrscheinlichkeit auszuwählen. Dazu spielt der Spieler zufällig eine bei Spielstart eingestellte Anzahl an Spielen ab der aktuellen Spielsituation und berechnet daraus den Anteil der gewonnen Spiele je verfügbaren Zug. Den Zug mit der höchsten Gewinnwahrscheinlichkeit wird nun im \mxZitat{realer} Zug des Spielers ausgewählt.

\subsection{Alpha-Beta Pruning}
Ebenso wie der Spieler \mxZitat{Monte Carlo} wird der Spielalgorithmus im Theorieteil erläutert. Der beste Zug wird dadurch berechnet, dass eine eingeschränkte Breitensuche bis zu einer bestimmten Tiefe durchgeführt wird, dabei allerdings auch der Gegenspieler beachtet wird.
Statt einer kompletten Tiefensuche mit MiniMax werden Züge mit einer geringen Zugwahrscheinlichkeit nicht evaluiert. Die Grundidee des Algorithmus ist, dass sowohl der aktuelle Spieler, als auch der Gegenspieler jeweils den für sie besten Zug und für den Gegner schlechtesten Zug spielen.
\\Nach der eingeschränkten Breitensuche können mehrere Möglichkeiten gewählt werden.
Es existieren einerseits mehrere Heuristiken, andererseits können auch andere Spieler ab diesen Spielzügen das Spiel berechnen. Diese Möglichkeiten werden in dem Kapitel \ref{ab_comb} genauer erläutert.

\subsection{Machine Learning}
Dieser Spielalgorithmus besteht hauptsächlich aus dem Monte Carlo Spieler. Der deutliche Unterschied zu diesem besteht aber in der Auswahl der zu simulierenden Spiele. Während Monte Carlo zufällig einen Zug aus den verfügbaren Zügen auswählt, verwendet Machine Learning eine gewichtete Zufallsfunktion. Der Algorithmus speichert die gespielten und gewonnen Spiele in einer Datenbank. Bei der Auswahl des Zuges, gewichtet er die Zugmöglichkeiten, die eine höhere Gewinnwahrscheinlichkeit besitzen höher als die Züge mit einer geringeren Wahrscheinlichkeit. Dadurch wählt er statistisch die Züge mit einer höheren Gewinnwahrscheinlichkeit aus. Durch das Speichern der Ergebnisse der simulierten Spiele in der Datenbank, \mxZitat{lernt} die Datenbank mit der Zeit dazu und kann in weiteren Spielen zuverlässigere Wahrscheinlichkeiten zurückgeben.

\section{Details zum Monte Carlo Spieler}
In diesem Kapitel wird der Spieler Monte Carlo anhand des vorhandenen Quellcodes detailliert erklärt.
\\Die Spielerklasse \mxZitat{PlayerMonteCarlo} ist in der Datei \mxZitat{python/Players/playerMonteCarlo.py} zu finden.
Die zunächst wichtigsten Funktionen sind die Init-Funktion der Klasse und die Funktion \mxZitat{get\_move}.
\subsection{Init-Funktion}
In dem Konstruktor der Klasse \code{PlayerMonteCarlo} werden mehrere Benutzerabfragen durchgeführt und in der Klasse gespeichert. Folgende Werte werden ermittelt:
\begin{itemize}
\item \code{big\_n}: Anzahl der zufällig gespielten Spiele je Zug
\item \code{use\_start\_libs}: Bool'scher Wert ob Startbibliotheken verwendet werden sollen.
\item \code{preprocessor}: Nummer des verwendeten Preprozessors. 0 entspricht der Deaktivierung der Option
\item \code{preprocessor\_parameter}: Parameter des verwendeten Preprozessors
\item \code{heuristic}: Wahl einer Heuristikfunktion
\end{itemize}

\subsection{get\_move}
 \mxZitat{get\_move} ist eine Interface-Funktion, d.h. alle Spieler stellen eine Funktion \mxZitat{get\_move} bereit, die als Parameter einen Spielzustand (Klasse \code{Othello}) erwartet und einen \code{move} zurückgibt. Dieser besteht aus einem Paar, das die Koordinaten auf dem Spielfeld darstellt. In Listing \ref{lst:ab1} ist die Funktion abgebildet.
\vspace{0.5cm}
\\In den Zeilen 3 bis 6 werden die Starttabellen verwendet, wenn diese in der init-Funktion ausgewählt wurden. Die Funktion \code{get\_available\_start\_tables} gibt eine Liste der möglichen Züge zurück (Z.4). Diese sind in der Form \mxZitat{a2} angegeben. Aus den verfügbaren Zügen wird zufällig ein Element ausgewählt \\(\code{moves[random.randrange(len(moves))]} Z.6) und dieses in ein Koordinatenpaar übersetzt \\(\code{translate\_move\_to\_pair} Z. 6). 
\\Ist die Liste der verfügbaren Züge leer, oder die Nutzung der Starttabellen deaktiviert, wird der Quellcode ab der Zeile 8 ausgeführt. In den Zeilen 8 bis 18 werden Variablen implementiert und ggf. der Preprozessor (Z. 13f.) ausgeführt.
\\Die in der Init-Funktion angegeben \code{big\_n} Spiele werden in der Schleife in den Zeilen 20 bis 26 durchgeführt.
\code{simulated\_game} ist eine Kopie des aktuellen Spielzustandes (Z. 21). Auf dieser Kopie wird nun ein zufälliges Spiel durchgeführt und gibt das Paar \code{(first\_played\_move, won)} zurück (Z. 23). Das lokale Dictionary \code{winning\_statistics} (Z. 25f.) speichert diese Werte und summiert die Anzahl der gewonnen Spielen.
Das Dictionary speichert für jeden Zug ein Paar, das die gewonnen Spiele und die Gesamtanzahl der Spiele darstellt.
\\ Nach dem Spielen aller zufälligen Spiele wird die Gewinnwahrscheinlichkeit berechnet (Z. 29 - 31). Die Wahrscheinlichkeit wird in dem Klassendictionary \code{move\_probability} gespeichert (Z. 31).
\\Abschließend wird das Maximum des Dictionary über die Wahrscheinlichkeiten ermittelt und zurückgegeben (Z. 33f.).

\begin{lstlisting}[caption = {get\_move Funktion des Alpha-Beta Spielers}, language = cpp, captionpos = t , numbers=left, label={lst:ab1}]
    def get_move(self, game_state: Othello):

        if self.use_start_lib and game_state.get_turn_nr() < 10:  # check whether start move match
            moves = self.start_tables.get_available_start_tables(game_state)
            if len(moves) > 0:
                return UtilMethods.translate_move_to_pair(moves[random.randrange(len(moves))])

        winning_statistics = dict()
        self.move_probability.clear()

        own_symbol = game_state.get_current_player()

        if self.preprocessor is not None:
            self.preprocessor(game_state, self.preprocessor_parameter, self.heuristic)

        possible_moves = game_state.get_available_moves()
        for move in possible_moves:
            winning_statistics[move] = (0, 1)  # set games played to 1 to avoid division by zero error

        for i in range(self.big_n):
            simulated_game = game_state.deepcopy()

            first_played_move, won = self.play_random_game(own_symbol, simulated_game)

            (won_games, times_played) = winning_statistics[first_played_move]
            winning_statistics[first_played_move] = (won_games + won, times_played + 1)


        for single_move in winning_statistics:
            (games_won, times_played) = winning_statistics[single_move]
            self.move_probability[single_move] = games_won / times_played

        selected_move = max(self.move_probability.items(), key=operator.itemgetter(1))[0]
        return selected_move
\end{lstlisting}

\section{Details zum Machine Learning Spieler}
In diesem Kapitel wird der Spieler Machine Learning anhand des vorhandenen Quellcodes detailliert erklärt.
\\Die Spielerklasse \mxZitat{PlayerMachineLearning} ist in der Datei \mxZitat{python/Players/playerMachineLearning.py} zu finden.
Die zunächst wichtigsten Funktionen sind die Init-Funktion der Klasse und die Funktion \mxZitat{get\_move}.
\subsection{Init-Funktion}
In dem Konstruktor der Klasse \code{PlayerMachineLearning} wir \code{big\_n}, d.h. die Anzahl der zufällig gespielten Spiele je Zug abgefragt.

\subsection{get\_move}
Die \code{get\_move} Funktion dieses Spielers besteht im wesentlichen aus der Funktion \code{get\_move} des Monte Carlo Spielers. Die beiden Unterschiede finden sich in der Schleife, die die zufälligen Spiele ausführt. Die Unterschiede sind in Listing \ref{lst:ml1} dargestellt. 
Statt der Funktion \code{play\_random\_game} (Z. 6) der \code{PlayerMonteCarlo} Klasse wird die Funktion \code{play\_weighted\_random\_game} (Z. 9) der Klasse \code{PlayerMachineLearning} und anschließend \code{update\_all\_weights} (Z. 10) ausgeführt. 
\\\code{play\_weighted\_random\_game} spielt ebenfalls zufällige Spiele, allerdings bevorzugt die random-Funktion gewonnene Spiele im Gegensatz zu verlorene oder unentschiedene Spiele.
\\ Zu diesem Zweck wurde eine Datenbank aufgebaut, die für eine gegebene Zugnummer und Position auf dem Spielbrett eine Gewinnwahrscheinlichkeit zurückliefert. Die Zufallsfunktion wählt aus der Summe der Wahrscheinlichkeiten aller möglichen Zugmöglichkeiten eine zufällige Zahl und ordnet dieser Zahl wieder einem Zug aus dieser Liste zu. Der genaue Aufbau der Datenbank ist in dem nächsten Unterkapitel erläutert.

\begin{lstlisting}[caption = {get\_move Funktion des Machine Learning Spielers}, language = cpp, captionpos = t , numbers=left, label={lst:ml1}]
    def get_move(self, game_state: Othello):
		# ...
        for i in range(self.big_n): 
			# ... 
			# Monte Carlo
			first_played_move, won = self.play_random_game(own_symbol, simulated_game)

			# Machine Learning
			won, first_played_move, played_moves = self.play_weighted_random_game(own_symbol, simulated_game)
			ml_database.update_all_weights(played_moves, won)
		# ...
\end{lstlisting}
\subsection{Aufbau und Funktion der Machine Learning Datenbank}
In Abbildung \ref{fig:db1} ist ein Ausschnitt der Datenbank dargestellt.
\\\mxPicture{17cm}{Datenbank-ml}{Aufbau der Machine Learning Datenbank}{Aufbau der Machine Learning Datenbank}{fig:db1}{}
Die Zeilen stellen die Zugnummern von 0 bis 64 in einer Schrittweite von vier dar. Die Spalten stellen jedes einzelne Feld dar. Sie starten bei \mxZitat{a1} und enden bei \mxZitat{h8}.
\\Jedes Feld der dadurch aufgespannten Tabelle enthält ein Paar, das die Anzahl der gewonnen Spiele und die Gesamtanzahl der Spiele darstellen, in welchen das jeweilige Feld benutzt wurde.
\\Initial sind alle Felder auf das Paar \mxZitat{(1, 1)} gesetzt. Dadurch wird in der späteren Berechnung der Gewinnwahrscheinlichkeiten eine Division durch Null vermieden.
\\Bei jedem Spiel, das mit mindestens einem Machine Learning Spieler gespielt wird, werden die Züge extrahiert und die Datenbank aktualisiert. Im folgenden wird dies an den beiden Beispielspiele aus Listing \ref{lst:ex1} erklärt.
\begin{lstlisting}[caption = {Auschnitte aus Zugfolge zweier Spiele}, language = cpp, captionpos = t , numbers=left, label={lst:ex1}]
Spiel 1 (verloren): c4 c5 e6 f5 ..
Spiel 2 (gewonnen): e6 f6 d3 e7 ..
\end{lstlisting}
Nach jedem Spiel wird die Datenbank aktualisiert (siehe Listing \ref{lst:ml1} Zeile 10). Dies bedeutet, dass die Zellen \mxZitat{c4, c5, e6} in der ersten Zeile und \mxZitat{f5} in der zweiten Zeile aktualisiert werden. Statt \mxZitat{(1, 1)} steht in diesen Zellen nun \mxZitat{(1, 2)}, da die Zellen in einem weiteren Spiel verwendet wurden (1 + 1 = 2), aber das letzte Spiel nicht gewonnen wurde (1 + 0 = 1). Nach dem zweiten Spiel werden ebenfalls die Zellen angepasst. in der Zelle \mxZitat{e6} steht nach dem ersten Spiel das Paar \mxZitat{(1, 2)}. Da dieses Spiel gewonnen wurde, werden beide Zahlen nun um eins inkrementiert.
\\Durch die Initialisierung der Zellen mit \mxZitat{(1, 1)} wird die Gewinnwahrscheinlichkeit (erste Komponente / zweite Komponente) etwas verzerrt. Beispielsweise ist die Gewinnwahrscheinlichkeit nach einem verlorenen Spiel nicht Null sonder 50 Prozent. Nach zwei verlorenen Spielen sinkt diese Wahrscheinlichkeit auf 33,33 Prozent. Bei sehr vielen Spielen, kann das eine gewonnene Spiel vernachlässigt werden und hat nur einen geringen Einfluss auf das Ergebnis.
\\Der Machine Learning Spieler nutzt diese Wahrscheinlichkeit, um einen gewichteten zufälligen Zug zu ermitteln.
In Abbildung \ref{fig:rand1} ist dieses Prinzip an einem Beispiel erklärt.
\\\mxPicture{13cm}{rand1}{Auswahl eines gewichteten zufälligen Zuges}{Auswahl eines gewichteten zufälligen Zuges}{fig:rand1}{}
Nach der Ermittlung der einzelnen Gewinnwahrscheinlichkeiten der verfügbaren Züge wird die Summe dieser Wahrscheinlichkeiten gebildet. Zu beachten ist, dass die Summe der Wahrscheinlichkeiten nicht 1 sein muss, sondern meistens bei der Hälfte der verfügbaren Züge liegt.
\\Aus dieser Summe (2,1) wird nun zufällig eine Zahl ausgewählt (1,2). Nun werden sequenziell die Wahrscheinlichkeiten der Züge summiert und dadurch ermittelt, welchen Zug die zufällige Zahl darstellt. In diesem Beispiel stellt eine \mxZitat{1,2} den Zug \mxZitat{f5} dar, da alle Zahlen in dem Intervall 1,1 bis 1,65 dem Zug \mxZitat{f5} zugeordnet sind.
\\Durch dieses Verfahren werden Züge mit einer höheren Wahrscheinlichkeit bevorteilt, aber nicht ausschließlich ausgewählt.  

\section{Details zum Spieler Alpha-Beta Pruning}
In diesem Kapitel wird der Spieler \mxZitat{Alpha-Beta Pruning} anhand des vorhandenen Quellcodes detailliert erklärt.
\\Die Spielerklasse \mxZitat{PlayerAlphaBetaPruning} ist in der Datei \mxZitat{python/Players/playerAlphaBetaPruning.py} zu finden.
Die zunächst wichtigsten Funktionen sind die Init-Funktion der Klasse und die Funktion \mxZitat{get\_move}.
\subsection{Init-Funktion}
In dem Konstruktor der Klasse \code{PlayerAlphaBetaPruning} werden folgende Benutzerabfragen getätigt:
\begin{itemize}
\item \code{search\_depth}: Tiefe der Alpha-Beta Suche
\item \code{use\_start\_libs}: Bool'scher Wert ob Startbibliotheken verwendet werden sollen.
\item \code{heuristic}: Nummer der verwendeten Heuristik
\item \code{use\_ml}: Verwende statt der Heuristik Machine Learning in der Tiefe \code{search\-depth} + 1
\item \code{use\_monte\_carlo}: Verwende statt der Heuristik Monte Carlo in der Tiefe \code{search\-depth} + 1
\item \code{ml\_count}: Anzahl der zufällig gespielten Spiele wenn Machine Learning oder Monte Carlo verwendet wird.
\end{itemize}

\subsection{get\_move}
In dem Listing \ref{lst:ab2} ist die \code{get\_move} Funktion des Alpha-Beta Pruning Spielers abgebildet.
Zunächst wird ebenfalls geprüft, ob die Starttabellen verwendet werden sollen (Z. 3 - 6).
\\Ist keine passende Starttabelle verfügbar, wird ab Zeile 8 Alpha-Beta Abschneiden durchgeführt.
Dies bedeutet,dass die Annahme getroffen wurde, dass jeder Spieler stets den besten Zug für sich, aber zeitgleich den schlechtmöglichsten Zug für den Gegner auswählt.
\\Der Algorithmus führt dadurch eine eingeschränkte Breitensuche bis zu einer bestimmten Tiefe durch.
Anschließend wird ein Wert ermittelt, der angibt, wie \mxZitat{gut} der gewählte Zug ist.
Diese Funktion \code{get\_value} existiert in drei unterschiedlichen Varianten.
Die erste Variante ist \code{value()} (Z. 19), welche eine Heuristik zur Berechnung des Wertes verwendet.  
Die zweite Variante ist \code{value\_ml()} (Z. 14), welche ab diesem Spielzustand das Spiel mit dem Machine Learning Algorithmus spielt und die Gewinnwahrscheinlichkeit des besten Zuges zurückgibt.
Die dritte Variante ist \code{value\_monte\_carlo()} (Z. 16), welche ab diesem Spielzustand das Spiel mit dem Monte Carlo Algorithmus spielt und die Gewinnwahrscheinlichkeit des besten Zuges zurückgibt.
\begin{lstlisting}[caption = {get\_move Funktion des Alpha-Beta Spielers}, language = cpp, captionpos = t , numbers=left, label={lst:ab2}]
    def get_move(self, game_state: Othello):

        if self.use_start_lib and game_state.get_turn_nr() < 10:  # check whether start move match
            moves = self.start_tables.get_available_start_tables(game_state)
            if len(moves) > 0:
                return UtilMethods.translate_move_to_pair(moves[random.randrange(len(moves))])
        
        best_moves = dict()
        for move in game_state.get_available_moves():
            next_state = game_state.deepcopy()
            next_state.play_position(move)

            if self.use_ml:
                result = -PlayerAlphaBetaPruning.value_ml(next_state, 
                				self.search_depth - 1, ml_count=self.ml_count)
            elif self.use_monte_carlo:
                result = -PlayerAlphaBetaPruning.value_monte_carlo(next_state, 
                				self.search_depth - 1, self.heuristic, mc_count=self.ml_count)
            else:
                result = -PlayerAlphaBetaPruning.value(next_state, self.search_depth - 1, self.heuristic)

            if result not in best_moves.keys():
                best_moves[result] = []
            best_moves[result].append(move)

        best_move = max(best_moves.keys())
        return best_moves[best_move][random.randrange(len(best_moves[best_move]))]
\end{lstlisting}

\section{Kombination von Monte-Carlo und Alpha-Beta Abschneiden}
\label{ab_comb}
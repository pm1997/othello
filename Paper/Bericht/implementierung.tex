\chapter{Implementierung der KI}
In den folgenden Unterkapiteln  werden verschiedene Spielalgorithmen vorgestellt und implementiert. Anschließend werden diese verbessert und auch unter Berücksichtigung des Laufzeitverhaltens analysiert.
\\Zunächst wird aber die grundsätzliche Programmstruktur erläutert und das Spielgerüst implementiert, damit unterschiedliche Spieler es ausführen können.
\section{Grundlegende Spiel-Elemente}
Die Python Implementierung befindet sich im Verzeichnis \mxZitat{python} des zu diesem Projekt gehörenden git Repository. Um das Spiel zur Ausführung zu bringen wird das Paket \mxZitat{numpy} benötigt. Ist diese Abhängigkeit vorhanden kann das Spiel durch ausführen des Kommandos \code{python main-game} gestartet werden.
\\Die einzelnen Komponenten wurden unter thematischen Gesichtspunkten in verschiedenen Dateien organisiert. Nachfolgend wird auf die einzelnen Dateien und deren Funktion kurz eingegangen.
\subsection{Der Spielablauf}
In \mxZitat{main-game.py}
\begin{lstlisting}[caption = {Spielablauf in \mxZitat{main-game.py}}, language = cpp, captionpos = t , numbers=left, label={lst:lst-main-game}]
    players = {PLAYER_ONE: player_one, PLAYER_TWO: player_two}
    game = Othello()
    game.init_game()
    game.print_board()
    while not game.game_is_over():
        current_player = game.get_current_player()
        player_object = players[current_player]
        move = player_object.get_move(game)
        game.play_position(move)
        game.print_board()
        print(f"Played position: ({COLUMN_NAMES[move[1]]}{move[0] + 1})")
    duration = time.time() - start
    print("Game is over")
    print(f"Total duration: {duration} seconds")
    print(f"Winner is {PRINT_SYMBOLS[game.get_winner()]}")
\end{lstlisting}
\subsection{Die Klasse \mxZitat{Othello}}
Die Klasse \mxZitat{Othello} modelliert einen Spielzustand und enthält die Grundlegende Spiellogik wie bspw. die Berechnung erlaubter Züge. Nachfolgend wird auf die Art der Speicherung eines Spielzustandes und auf die wichtigsten Funktionen dieser Klasse eingegangen.
\paragraph{Klassenvariablen}
In Listing \ref{lst:class-vars-othello} sind alle Klassenvariablen, sowie deren Initialisierungswerte angegeben.
\begin{enumerate}
\item \code{\_board}: Bei \code{\_board} handelt es sich um eine Liste von Listen, zur Modellierung der zweidimensionalen Struktur des Spielbretts. Initialisiert wird das Spielbrett in seinem Leerzustand. Daher wird zu Beginn jedes Feld auf \code{0} zur Repräsentation des leeren Feldes gesetzt.
\item \code{\_current\_player}: Speichert den Spieler, der im modellierten Spielzustand an der Reihe ist.
\item \code{\_last\_turn\_passed} wird verwendet um zu speichern ob der vorherige Spieler  passen musste. Dadurch kann das Spiel sobald zwei Spieler unmittelbar nacheinander passen müssen beendet werden.
\item \code{\_game\_is\_over} wird auf \code{True} gesetzt sobald das Spiel beendet ist
\item \code{\_fringe}] In \code{\_fringe} werden alle Felder des Spielfeldes gespeichert die in eine Richtung unmittelbar neben einem bereits besetzten Feld liegen. Durch die Mitführung dieser Information muss zur Berechnung der erlaubten Züge nicht jedes mal über das Spielfeld iteriert werden um zunächst die infrage kommenden Felder zu ermitteln.
\item \code{\_turning\_stones}: Enthält als Schlüssel alle erlaubten Züge und als Wert jeweils eine Liste jener Spielsteine die durch ausführen des Zuges umgedreht werden. Da zur Ermittlung der erlaubten Züge diese Information bereits berechnet werden muss wird sie in Form des Dictionarys vorgehalten um diese an anderer Stelle nicht erneut berechnen zu müssen.
\item \code{\_taken\_moves}: Speichert alle ausgeführten Züge die erforderlich waren um den modellierten Spielzustand zu erreichen, da einige Algorithmen diese Information benötigen.
\item \code{\_turn\_nr}: Speichert die Nummer des aktuellen Spielzuges, da die verwendete Strategie bei einigen Algorithmen davon abhängt, wie weit das Spiel schon fortgeschritten ist.
\end{enumerate}
\begin{lstlisting}[caption = {Klassenvariablen der Klasse \mxZitat{Othello}}, language = cpp, captionpos = t , numbers=left, label={lst:class-vars-othello}]
    _board = [[0 for _ in range(8)] for _ in range(8)]
    _current_player = None
 
    _last_turn_passed = False
    _game_is_over = False

    _fringe = set()
    _turning_stones = dict()
    
    _taken_moves = dict()
    _turn_nr = 0
\end{lstlisting}
\paragraph{Die Funktion \code{\_compute\_available\_moves}}
 ist in Listing \ref{lst:fct-compute-available-moves} angegeben und wird verwendet um die Inhalte des Dictionaries \code{\_turning\_stones} zu berechnern.
\\Da beiden Spielern in der Regel nicht die gleichen Züge zur Verfügung stehen muss zunaächst der vorherige Inhalt von \code{\_turning\_stones} gelöscht werden. Dies geschieht in Zeile 2 indem die Datenstruktur neu initialisiert wird.
\\In Zeile 3 wird eine lokale Referenz des zur Darstellung eines durch den aktuellen Spieler besetzen Feldes verwendeten Symbols erzeugt.
\\Mit der in Zeile 4 beginnenden Schleife wird über alle in Frage kommenden Züge in der Menge \code{\_fringe} iteriert um zu ermitteln, ob dieser Zug erlaubt wäre.
\\Dazu wird zunächst eine lokale Menge initialisiert um die durch spielen dieser Position gedrehten Steine zu speichern (Zeile 5).
\\Nun muss ausgehend von der derzeit betrachteten Position ermittelt werden ob in irgendeine Richtung Spielsteine gedreht werden würden. Dies erfolgt durch die in Zeile 6 beginnende Schleife.
\\Dazu wird zunächst das nächste Feld in diese Richtung unter Verwendung einer Hilfsfunktion ermittelt (Zeile 7) und anschließend eine weitere termporäre Menge der in dieser Richtung gedrehten Steine initialisiert (Zeile 8)
\\Die entsprechende Richtung muss nun solange weiter verfolgt werden wie ein weiterer Nachbar in diese Richtung vorhanden ist. Dies geschieht durch die in Zeile 9 beginnedne Schleife.
\\Da in den nachfolgenden Schritten ermittelt werden muss welcher Spieler das derzeit betrachtete Feld besetzt hat, werden die Indizes der derzeitigen  ausgepackt (Zeile 10) und dann verwendet um zu ermitteln welchen Wert das Feld detzeit hat (Zeile 11).
\\Nun gibt es drei mögliche Fälle:
\begin{enumerate}
\setcounter{enumi}{0}
\item Es befindet sich kein Stein auf dem derzeit betrachteten Feld. In diesem Fall wird die Abfrage in Zeile 12 positiv ausgewertet und diese Richtung muss nicht weiter verfolgt werden. Entsprechend wird die while-Schleife in Zeile 13 abgebrochen.
\item Das derzeit betrachtete Feld wird durch den anderen Spieler besetzt. In diesem Fall ist die Abfrage in Zeile 14 positiv. Da der Stein ggf. umgedreht werden würde, wird die aktuelle Position gespeichert (Zeile 15)
\item Das derzeit betrachtete Feld wird durch den Spieler selbst besetzt. In diesem Fall wird die Abfrage in Zeile 16 positiv ausgewertet. Nun werden alle Steine zwischen der Ausgangsposition und der derzeitigen gedreht. Daher wird die Menge der durch diesen Zug gedrehten Steine mit der in diese Richtung befindlichen Steine vereinigt (Zeile 17) und die Schleife verlassen (Zeile 18).
\end{enumerate}
In Zeile 19 wird das nächste Feld in diese Richtung berechnet.
\\Gemäß der Regeln muss durch jeden Zug mindestens ein Stein gedreht werden. Aus diesem Grund wird nun ermittelt ob dies bei diesem Zug gegeben wäre (Zeile 20). Ist dies der Fall so werden die gedrehten Steine für diesen Zug in \code{\_stones\_to\_turn} gespeichert (Zeile 21).
\\Hat ein Spieler nun keine Möglichkeiten einen Zug durchzuführen, so sind in \code{\_stones\_to\_turn} keine Züge enthalten. Dieser Fall muss besonders behandelt werden. Tritt er ein, so wird die Abfrage in Zeile 22 positiv ausgewertet.
\\In diesem Fall muss nochmal unterschieden werden, ob der vorherige Spieler ebenfalls keinen Zug zur Auswahl hatte (Zeile 23).
\\Falls ja so ist das Spiel zu ende. Dies wird durch setzen von \code{\_game\_is\_over} gespeichert (Zeile 24).
\\Falls nein (Zeile 25), so wird gespeichert, dass der Spieler passen musste (Zeile 26) und der nächste Zug vorbereitet (Zeile 27)
Hat der Spieler hingegen eine Zugmöglichkeit (Zeile 28) so hat er aus Sicht des folgenden Zuges nicht passen müssen. Entsprechend wird \code{\_last\_turn\_passed} wieder auf \code{False} gesetzt. 
\begin{lstlisting}[caption = {Die Funktion \code{\_compute\_available\_moves}}, language = cpp, captionpos = t , numbers=left, label={lst:fct-compute-available-moves}]
    def _compute_available_moves(self):
        self._turning_stones = dict()
        own_symbol = self._current_player
        for current_position in self._fringe:
            position_turns = set()
            for direction in DIRECTIONS:
                next_step = Othello._next_step(current_position, direction)
                this_direction = set()
                while next_step is not None:
                    (current_x, current_y) = next_step
                    current_value = self._board[current_x][current_y]
                    if current_value == EMPTY_CELL:
                        break
                    elif current_value != own_symbol:
                        this_direction.add(next_step)
                    elif current_value == own_symbol:
                        position_turns = position_turns | this_direction
                        break
                    next_step = Othello._next_step(next_step, direction)
            if len(position_turns) > 0:
                self._turning_stones[current_position] = position_turns
        if len(self._turning_stones) == 0:
            if self._last_turn_passed:
                self._game_is_over = True
            else:
                self._last_turn_passed = True
                self._prepare_next_turn()
        else:
            self._last_turn_passed = False
\end{lstlisting}
\paragraph{Weitere Funktionen der Klasse \mxZitat{Othello}}
Die Klasse \mxZitat{Othello} enthält weitere Funktionen auf die hier jedoch nicht im Detail eingegangen werden soll. Dennoch sei hier jeweils kurz deren Verwendungszweck der wichtigsten Funktionen genannt:
\begin{enumerate}
\item \code{play\_position} verändert den Spielzustand dahingehend, dass der übergebene Zug, sofern er erlaubt ist, ausgeführt wird, die entsprechenden Steine des Gegners gedreht und dessen Zug vorbereitet wird. Dabei wird auch die \code{\_fringe} entsprechend aktualisiert.
\item \code{set\_available\_moves} verändert \code{\_stones\_to\_turn} dahingehend, dass nur noch übergebene Positionen enthalten sind. Kann damit zum Filtern der erlaubten Züge verwendet werden.
\item \code{get\_available\_moves}: Gibt die erlaubten Züge zur Verwendung in den Spieler-\\implementierungen zurück
\item \code{other\_player}: Gibt das Symbol des anderen Spielers zurück
\item \code{utility}: Gibt gemäß der Definition eines Spiels 0, 1 oder -1 zurück.
\item \code{get\_winner}: Ermittelt den Gewinner des Spiels und gibt ihn zurück.
\item \code{get\_statistics}: Gibt die Anzahl der Felder pro Spieler zurück.
\item \code{get\_current\_player}: Gibt den derzeitigen Spieler zurück.
\item \code{game\_is\_over}: Gibt zurück ob das Spiel bereits zu Ende ist.
\item \code{init\_game}: Bereitet den Start eines Spiels vor indem die initial besetzen Felder entsprechen gesetzt werden. Der beginnende Spieler festgelegt und die  \code{\_fringe} vorbereitet, sowie \code{\_stones\_to\_turn} für den ersten Zug berechnet.
\end{enumerate}
\subsection{Die übrigen Komponenten}
\section{Agenten}
Beim Start eines Partie stehen dem Nutzer mehrere Agenten zur Auswahl die die Rolle eines Spielers übernehmen können. Die Implementierung zu diesen Agenten befindet sich in Unterverzeichnis \code{Agents}.
\\Die folgende Agenten stehen dabei zur Auswahl:
\begin{enumerate}
\setcounter{enumi}{-1}
\item Human
\item Random Player
\item Monte Carlo
\item Alpha-Beta Pruning
\end{enumerate}
\subsection{Human Agent}
Der \mxZitat{Human Agent} bzw. menschlische Agent stellt eine Schnittstelle die es einem menschlichen Spieler ermöglicht eine Spielentscheidung zu treffen. Die Implementierung findet sich in der Datei \code{human.py}
\\Neben dem Spielfeld bekommt der Nutzer dabei eine Liste aller für Ihn möglichen Züge dargestellt. Durch die Eingabe eines Zuges wird dieser im Spielmodell ausgeführt und der nächste Agent wird aufgerufen. Da das Ziel dieser Arbeit darin besteht eine künstliche Intelligenz zur Wahl der Züge zu entwicklen, soll an dieser Stelle nicht weiter auf diesen Agenten eingegangen sein.

\subsection{Random}
Der Spieler Random wählt aus der Liste der möglichen Züge zufällig einen Zug aus und gibt diesen an die Hauptfunktion zurück.

\subsection{Monte Carlo}
Dieser Spieler verwendet den in Kapitel \ref{mc_algo} verwendeten Algorithmus um den Zug mit der höchsten Gewinnwahrscheinlichkeit auszuwählen. Dazu spielt der Spieler zufällig eine bei Spielstart eingestellte Anzahl an Spielen ab der aktuellen Spielsituation und berechnet daraus den Anteil der gewonnen Spiele je verfügbaren Zug. Den Zug mit der höchsten Gewinnwahrscheinlichkeit wird nun im \mxZitat{realer} Zug des Spielers ausgewählt.
\subsubsection{Details zum Monte Carlo Spieler}
In diesem Kapitel wird der Spieler Monte Carlo anhand des vorhandenen Quellcodes detailliert erklärt.
\\Die Spielerklasse \mxZitat{PlayerMonteCarlo} ist in der Datei \mxZitat{python/Players/playerMonteCarlo.py} zu finden.
Die zunächst wichtigsten Funktionen sind die Init-Funktion der Klasse und die Funktion \mxZitat{get\_move}.
\paragraph{init-Funktion}
In dem Konstruktor der Klasse \code{PlayerMonteCarlo} werden mehrere Benutzerabfragen durchgeführt und in der Klasse gespeichert. Folgende Werte werden ermittelt:
\begin{itemize}
\item \code{big\_n}: Anzahl der zufällig gespielten Spiele je Zug
\item \code{use\_start\_libs}: Bool'scher Wert ob Startbibliotheken verwendet werden sollen.
\item \code{preprocessor}: Nummer des verwendeten Preprozessors. 0 entspricht der Deaktivierung der Option
\item \code{preprocessor\_parameter}: Parameter des verwendeten Preprozessors
\item \code{heuristic}: Wahl einer Heuristikfunktion
\end{itemize}

\paragraph{get\_move}
 \mxZitat{get\_move} ist eine Interface-Funktion, d.h. alle Spieler stellen eine Funktion \mxZitat{get\_move} bereit, die als Parameter einen Spielzustand (Klasse \code{Othello}) erwartet und einen \code{move} zurückgibt. Dieser besteht aus einem Paar, das die Koordinaten auf dem Spielfeld darstellt. In Listing \ref{lst:ab1} ist die Funktion abgebildet.
\vspace{0.5cm}
\\In den Zeilen 3 bis 6 werden die Starttabellen verwendet, wenn diese in der init-Funktion ausgewählt wurden. Die Funktion \code{get\_available\_start\_tables} gibt eine Liste der möglichen Züge zurück (Z.4). Diese sind in der Form \mxZitat{a2} angegeben. Aus den verfügbaren Zügen wird zufällig ein Element ausgewählt \\(\code{moves[random.randrange(len(moves))]} Z.6) und dieses in ein Koordinatenpaar übersetzt \\(\code{translate\_move\_to\_pair} Z. 6). 
\\Ist die Liste der verfügbaren Züge leer, oder die Nutzung der Starttabellen deaktiviert, wird der Quellcode ab der Zeile 8 ausgeführt. In den Zeilen 8 bis 18 werden Variablen implementiert und ggf. der Preprozessor (Z. 13f.) ausgeführt.
\\Die in der Init-Funktion angegeben \code{big\_n} Spiele werden in der Schleife in den Zeilen 20 bis 26 durchgeführt.
\code{simulated\_game} ist eine Kopie des aktuellen Spielzustandes (Z. 21). Auf dieser Kopie wird nun ein zufälliges Spiel durchgeführt und gibt das Paar \code{(first\_played\_move, won)} zurück (Z. 23). Das lokale Dictionary \code{winning\_statistics} (Z. 25f.) speichert diese Werte und summiert die Anzahl der gewonnen Spielen.
Das Dictionary speichert für jeden Zug ein Paar, das die gewonnen Spiele und die Gesamtanzahl der Spiele darstellt.
\\ Nach dem Spielen aller zufälligen Spiele wird die Gewinnwahrscheinlichkeit berechnet (Z. 29 - 31). Die Wahrscheinlichkeit wird in dem Klassendictionary \code{move\_probability} gespeichert (Z. 31).
\\Abschließend wird das Maximum des Dictionary über die Wahrscheinlichkeiten ermittelt und zurückgegeben (Z. 33f.).

\begin{lstlisting}[caption = {get\_move Funktion des Alpha-Beta Spielers}, language = cpp, captionpos = t , numbers=left, label={lst:ab1}]
    def get_move(self, game_state: Othello):

        if self.use_start_lib and game_state.get_turn_nr() < 10:  # check whether start move match
            moves = self.start_tables.get_available_start_tables(game_state)
            if len(moves) > 0:
                return UtilMethods.translate_move_to_pair(moves[random.randrange(len(moves))])

        winning_statistics = dict()
        self.move_probability.clear()

        own_symbol = game_state.get_current_player()

        if self.preprocessor is not None:
            self.preprocessor(game_state, self.preprocessor_parameter, self.heuristic)

        possible_moves = game_state.get_available_moves()
        for move in possible_moves:
            winning_statistics[move] = (0, 1)  # set games played to 1 to avoid division by zero error

        for i in range(self.big_n):
            simulated_game = game_state.deepcopy()

            first_played_move, won = self.play_random_game(own_symbol, simulated_game)

            (won_games, times_played) = winning_statistics[first_played_move]
            winning_statistics[first_played_move] = (won_games + won, times_played + 1)


        for single_move in winning_statistics:
            (games_won, times_played) = winning_statistics[single_move]
            self.move_probability[single_move] = games_won / times_played

        selected_move = max(self.move_probability.items(), key=operator.itemgetter(1))[0]
        return selected_move
\end{lstlisting}

\subsection{Alpha-Beta Pruning}
Ebenso wie der Spieler \mxZitat{Monte Carlo} wird der Spielalgorithmus im Theorieteil erläutert. Der beste Zug wird dadurch berechnet, dass eine eingeschränkte Breitensuche bis zu einer bestimmten Tiefe durchgeführt wird, dabei allerdings auch der Gegenspieler beachtet wird.
Statt einer kompletten Tiefensuche mit MiniMax werden Züge mit einer geringen Zugwahrscheinlichkeit nicht evaluiert. Die Grundidee des Algorithmus ist, dass sowohl der aktuelle Spieler, als auch der Gegenspieler jeweils den für sie besten Zug und für den Gegner schlechtesten Zug spielen.
\\Nach der eingeschränkten Breitensuche können mehrere Möglichkeiten gewählt werden.
Es existieren einerseits mehrere Heuristiken, andererseits können auch andere Spieler ab diesen Spielzügen das Spiel berechnen. Diese Möglichkeiten werden in dem Kapitel \ref{ab_comb} genauer erläutert.

\subsubsection{Details zum Spieler Alpha-Beta Pruning}
In diesem Kapitel wird der Spieler \mxZitat{Alpha-Beta Pruning} anhand des vorhandenen Quellcodes detailliert erklärt.
\\Die Spielerklasse \mxZitat{PlayerAlphaBetaPruning} ist in der Datei \mxZitat{python/Players/playerAlphaBetaPruning.py} zu finden.
Die zunächst wichtigsten Funktionen sind die Init-Funktion der Klasse und die Funktion \mxZitat{get\_move}.
\paragraph{Init-Funktion}
In dem Konstruktor der Klasse \code{PlayerAlphaBetaPruning} werden folgende Benutzerabfragen getätigt:
\begin{itemize}
\item \code{search\_depth}: Tiefe der Alpha-Beta Suche
\item \code{use\_start\_libs}: Bool'scher Wert ob Startbibliotheken verwendet werden sollen.
\item \code{heuristic}: Nummer der verwendeten Heuristik
\item \code{use\_ml}: Verwende statt der Heuristik Machine Learning in der Tiefe \code{search\-depth} + 1
\item \code{use\_monte\_carlo}: Verwende statt der Heuristik Monte Carlo in der Tiefe \code{search\-depth} + 1
\item \code{ml\_count}: Anzahl der zufällig gespielten Spiele wenn Machine Learning oder Monte Carlo verwendet wird.
\end{itemize}

\paragraph{get\_move}
In dem Listing \ref{lst:ab2} ist die \code{get\_move} Funktion des Alpha-Beta Pruning Spielers abgebildet.
Zunächst wird ebenfalls geprüft, ob die Starttabellen verwendet werden sollen (Z. 3 - 6).
\\Ist keine passende Starttabelle verfügbar, wird ab Zeile 8 Alpha-Beta Abschneiden durchgeführt.
Dies bedeutet,dass die Annahme getroffen wurde, dass jeder Spieler stets den besten Zug für sich, aber zeitgleich den schlechtmöglichsten Zug für den Gegner auswählt.
\\Der Algorithmus führt dadurch eine eingeschränkte Breitensuche bis zu einer bestimmten Tiefe durch.
Anschließend wird ein Wert ermittelt, der angibt, wie \mxZitat{gut} der gewählte Zug ist.
Diese Funktion \code{get\_value} existiert in drei unterschiedlichen Varianten.
Die erste Variante ist \code{value()} (Z. 19), welche eine Heuristik zur Berechnung des Wertes verwendet.  
Die zweite Variante ist \code{value\_ml()} (Z. 14), welche ab diesem Spielzustand das Spiel mit dem Machine Learning Algorithmus spielt und die Gewinnwahrscheinlichkeit des besten Zuges zurückgibt.
Die dritte Variante ist \code{value\_monte\_carlo()} (Z. 16), welche ab diesem Spielzustand das Spiel mit dem Monte Carlo Algorithmus spielt und die Gewinnwahrscheinlichkeit des besten Zuges zurückgibt.
\begin{lstlisting}[caption = {get\_move Funktion des Alpha-Beta Spielers}, language = cpp, captionpos = t , numbers=left, label={lst:ab2}]
    def get_move(self, game_state: Othello):

        if self.use_start_lib and game_state.get_turn_nr() < 10:  # check whether start move match
            moves = self.start_tables.get_available_start_tables(game_state)
            if len(moves) > 0:
                return UtilMethods.translate_move_to_pair(moves[random.randrange(len(moves))])
        
        best_moves = dict()
        for move in game_state.get_available_moves():
            next_state = game_state.deepcopy()
            next_state.play_position(move)

            if self.use_ml:
                result = -PlayerAlphaBetaPruning.value_ml(next_state, 
                				self.search_depth - 1, ml_count=self.ml_count)
            elif self.use_monte_carlo:
                result = -PlayerAlphaBetaPruning.value_monte_carlo(next_state, 
                				self.search_depth - 1, self.heuristic, mc_count=self.ml_count)
            else:
                result = -PlayerAlphaBetaPruning.value(next_state, self.search_depth - 1, self.heuristic)

            if result not in best_moves.keys():
                best_moves[result] = []
            best_moves[result].append(move)

        best_move = max(best_moves.keys())
        return best_moves[best_move][random.randrange(len(best_moves[best_move]))]
\end{lstlisting}